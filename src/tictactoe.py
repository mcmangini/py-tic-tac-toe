#!/usr/bin/env python3

import sys
import random

BOARD_SIZE = 3
VALID_PLAYERS = ['0', '1', '2']
VALID_AI_LEVEL = ['1', '2', '3', '4']
VALID_X = ['a', 'b', 'c']
VALID_Y = ['3', '2', '1']

# Cache used to store scores generated by minimax algorithm.
# Cache is checked before generating a new score. Significantly cuts down
# minimax computation time.
minimax_cache = {}


def board_to_string(board):
    """Return a unique string identifier for the given board object.

    Used as the key for storing the board in the cache.
    """
    s = ''
    for row in board:
        for cell in row:
            if cell is None:
                s += '_'
            else:
                s += cell
    return s


def rotate_board(board):
    """Return a copy of the board rotated 90 degrees clockwise."""
    rotated_board = new_board()
    for y in range(len(board)):
        for x in range(len(board[0])):
            rotated_board[x][abs(y - 2)] = board[y][x]
    return rotated_board


def get_all_rotations(board):
    """Return a list containing the four possible rotations of the board."""
    b = board
    all_rotations = [b]
    for i in range(3):
        rotated_board = rotate_board(b)
        all_rotations.append(rotated_board)
        b = rotated_board
    return all_rotations


def add_rotations_to_cache(board, score):
    """Add all rotations of board to the cache with the same score.

    All rotations of a board are given the same score.
    Therefore, to save time, we should add them all at once, rather than
    calculating them separately.
    """
    for rotated_board in get_all_rotations(board):
        rotated_board_id = board_to_string(rotated_board)
        minimax_cache[rotated_board_id] = score


def new_board():
    """Return a list of lists representing an empty board.

    A board is square, so the list will have BOARD_SIZE sub-lists,
    each with BOARD_SIZE elements.
    Regular tic-tac-toe uses a 3x3 board.
    """
    board = []
    for i in range(BOARD_SIZE):
        row = []
        for j in range(BOARD_SIZE):
            row.append(None)
        board.append(row)
    return board


def render(board):
    """Print a visual representation of the board.

    The letters 'abc' are used for x-coordinates and the numbers
    '123' for y-coordinates.
    """
    h_coords = '    a b c '
    h_divider = '   -------'
    print(h_divider)
    for i, row in enumerate(board):
        pretty_row = str(BOARD_SIZE - i) + ' | '
        for cell in row:
            if cell is None:
                cell_as_str = '  '
            else:
                cell_as_str = str(cell) + ' '
            pretty_row += cell_as_str
        pretty_row += '|'
        print(pretty_row)
    print(h_divider)
    print(h_coords)


def get_move(current_player):
    """Prompt the player for a move and return it as (x, y) coordinates.

    Checks whether the input is a valid move, and if not prompts
    the user again. This continues until a valid move is entered
    or the user types 'quit.'
    A valid move is then converted into an (x, y) tuple and returned.
    """
    while True:
        move_input = input(f'Enter move ({current_player}): ')
        if move_input.lower() == 'quit':
            sys.exit(0)
        if is_valid_move(move_input):
            break
        else:
            continue
    x = move_input[0].lower()
    y = move_input[1]
    adjusted_x = VALID_X.index(x)
    adjusted_y = VALID_Y.index(y)
    return (adjusted_x, adjusted_y)


def is_valid_move(move):
    """Return True if the move is valid, False otherwise.

    Valid moves are strings two characters in length, the first
    character being 'a', 'b' or 'c', the second character
    being '1', '2' or '3' (as listed in VALID_X and VALID_Y).
    """
    if len(move) != 2:
        print('Invalid move. Move must be two characters.')
        return False
    x = move[0].lower()
    y = move[1]
    if x not in VALID_X:
        print('Invalid move. First character must be a, b or c.')
        return False
    if y not in VALID_Y:
        print('Invalid move. Second character must be 1, 2 or 3.')
        return False
    return True


def is_move_available(board, move):
    """Return False if move has already been played, True otherwise."""
    x = move[0]
    y = move[1]
    if board[y][x] is not None:
        print('Invalid move. Position already taken.')
        return False
    return True


def make_move(board, move, player):
    """Return a new board that contains the move.

    'player' parameter determines whether the move is an 'X' or an 'O'.
    Returns a copy of the board. The original is not modified.
    """
    x = move[0]
    y = move[1]
    updated_board = new_board()
    for i in range(len(board)):
        for j in range(len(board[0])):
            updated_board[i][j] = board[i][j]
    if updated_board[y][x] is not None:
        raise Exception('Error. Position already taken.')

    updated_board[y][x] = player
    return updated_board


def play(board, current_player):
    """Two players. Add moves to board recursively until the game is over.

    Main loop for a two-player game. Prompts for a move, plays the move
    then checks whether someone has won or if the game is drawn. If
    neither, calls itself again with updated board and opponent as
    current player.
    """
    move_coords = human_player(board, current_player)
    updated_board = make_move(board, move_coords, current_player)
    render(updated_board)

    winner = get_winner(updated_board)
    if winner is not None:
        print(f'{winner} wins!')
        prompt_rematch()

    draw = check_draw(updated_board)
    if not draw:
        current_player = get_opponent(current_player)
        play(updated_board, current_player)
    else:
        print('Draw!')
        prompt_rematch()


def play_vs_cpu(board, current_player, human_symbol, ai_level):
    """One player. Add moves to board recursively until the game is over.

    Main loop for a one-player game. Alternates turns between user and
    a CPU.
    'ai_level' parameter is a function that determines the CPUs behavior
    when making moves.
    """
    if current_player == human_symbol:
        move_coords = human_player(board, current_player)
    else:
        move_coords = ai_level(board, current_player)
    updated_board = make_move(board, move_coords, current_player)
    render(updated_board)

    winner = get_winner(updated_board)
    if winner is not None:
        print(f'{winner} wins!')
        prompt_rematch()

    draw = check_draw(updated_board)
    if not draw:
        current_player = get_opponent(current_player)
        play_vs_cpu(updated_board, current_player, human_symbol, ai_level)
    else:
        print('Draw!')
        prompt_rematch()


def invert_minimax_cache():
    """Multiply each score in the cache by -1.

    This is done to reflect the change in perspective when alternating
    turns between CPUs. If, for the current CPU, a score of 10 represents
    a winning move and -10 a losing move, it follows that the reverse is
    true for the opposing CPU.
    This allows us to use the same cache for both CPUs.
    """
    for key in minimax_cache:
        minimax_cache[key] *= -1


def cpu_vs_cpu(board, current_player, x_ai, o_ai):
    """Zero players. Add moves to board recursively until the game is over.

    Main loop for a zero-player game. Alternates turns between two CPUs.
    'x_ai' and 'o_ai' parameters are functions that determine the CPU
    behavior when making moves.
    """
    if current_player == 'X':
        ai_type = x_ai
    else:
        ai_type = o_ai
    move_coords = ai_type(board, current_player)
    invert_minimax_cache()
    updated_board = make_move(board, move_coords, current_player)
    render(updated_board)

    winner = get_winner(updated_board)
    if winner is not None:
        print(f'{winner} wins!')
        prompt_rematch()

    draw = check_draw(updated_board)
    if not draw:
        current_player = get_opponent(current_player)
        cpu_vs_cpu(updated_board, current_player, x_ai, o_ai)
    else:
        print('Draw!')
        prompt_rematch()


def get_ai_level(symbol):
    """Return a CPU behavior function corresponding to user input.

    'symbol' parameter is displayed when prompting the user for input.
    """
    while True:
        if symbol is not None:
            ai_level = input(f'{symbol} AI Level? (1, 2, 3, 4): ')
        else:
            ai_level = input('AI Level? (1, 2, 3, 4): ')
        if ai_level in VALID_AI_LEVEL:
            match int(ai_level):
                case 1:
                    return random_ai
                case 2:
                    return finds_winning_moves_ai
                case 3:
                    return finds_winning_and_losing_moves_ai
                case 4:
                    return minimax_ai
        else:
            print('Invalid input. Type 1, 2, 3 or 4.')


def prompt_rematch():
    """Set up a new game or quit."""
    while True:
        play_again = input('Play again? (y, n): ')
        if play_again.lower() == 'y':
            break
        elif play_again.lower() == 'n':
            sys.exit(0)
        else:
            print('Invalid input. Type y or n.')

    minimax_cache.clear()
    number_of_players = get_number_of_players()
    board = new_board()
    if number_of_players == 0:
        x_ai = get_ai_level('X')
        o_ai = get_ai_level('O')
        render(board)
        cpu_vs_cpu(board, 'X', x_ai, o_ai)
    elif number_of_players == 1:
        ai_level = get_ai_level(None)
        render(board)
        play_vs_cpu(board, 'X', assign_player_symbol(), ai_level)
    else:
        render(board)
        play(board, 'X')


def get_all_lanes(board):
    """Return list of all eight lanes containing three spaces in a row.

    A lane is any group of three-in-a-row on the board.
    This includes three rows, three columns and two diagonals.
    """
    all_lanes = []
    # Get the three rows
    for y in range(len(board)):
        row = []
        for x in range(len(board[0])):
            row.append(board[y][x])
        all_lanes.append(row)

    # Get the three columns
    for x in range(len(board[0])):
        col = []
        for y in range(len(board)):
            col.append(board[y][x])
        all_lanes.append(col)

    # Get the two diagonals
    top_left_diag = [board[0][0], board[1][1], board[2][2]]
    all_lanes.append(top_left_diag)
    top_right_diag = [board[0][2], board[1][1], board[2][0]]
    all_lanes.append(top_right_diag)

    return all_lanes


def get_winner(board):
    """Return symbol of winner ('X' or 'O'), or None if there is none.

    A board has a winner if any lane contains three of the same symbol,
    e.g 'XXX' or 'OOO'.
    """
    all_lanes = get_all_lanes(board)
    for lane in all_lanes:
        if lane[0] == lane[1] == lane[2]:
            if lane[0] is not None:
                return lane[0]
    return None


def check_draw(board):
    """Return True if there are no moves left, False otherwise."""
    for row in board:
        for cell in row:
            if cell is None:
                return False
    return True


def get_number_of_players():
    """Prompt user for number of players and return input cast as an int.

    Valid inputs are 0, 1 or 2.
    """
    while True:
        number_of_players = input('How many players? (0, 1, 2): ')
        if number_of_players in VALID_PLAYERS:
            return int(number_of_players)
        print('Invalid input. Type 0, 1 or 2.')


def get_all_available_moves(board):
    """Return list of empty cells on the board."""
    available_moves = []
    for y in range(len(board)):
        for x in range(len(board[0])):
            if board[y][x] is None:
                available_moves.append((x, y))
    return available_moves


def random_ai(board, current_player):
    """Return a random available move."""
    available_moves = get_all_available_moves(board)
    move_index = random.randint(0, len(available_moves) - 1)
    return available_moves[move_index]


def copy_board(board):
    """Return a copy of the board."""
    copy = new_board()
    for y in range(len(board)):
        for x in range(len(board[0])):
            copy[y][x] = board[y][x]
    return copy


def finds_winning_moves_ai(board, current_player):
    """Return a winning move if it exists, otherwise return random move.

    A winning move is a move that will make three-in-a-row and
    immediately win the game.
    """
    available_moves = get_all_available_moves(board)

    for move in available_moves:
        updated_board = make_move(board, move, current_player)
        winner = get_winner(updated_board)
        if winner == current_player:
            return move

    return random_ai(board, current_player)


def finds_winning_and_losing_moves_ai(board, current_player):
    """Return move that wins, move that prevents loss, or random move.

    First, look for a move that will immediately win. If none is found,
    look for a move that will prevent the opponent from winning. If none
    is found, play a random move.
    """
    available_moves = get_all_available_moves(board)

    for move in available_moves:
        updated_board = make_move(board, move, current_player)
        winner = get_winner(updated_board)
        if winner == current_player:
            return move

    opponent = get_opponent(current_player)
    for move in available_moves:
        updated_board = make_move(board, move, opponent)
        winner = get_winner(updated_board)
        if winner == opponent:
            return move

    return random_ai(board, current_player)


def human_player(board, current_player):
    """Prompt user for move and return it.

    Allows the user the exit the game via a KeyboardInterrupt.
    """
    while True:
        try:
            move_coords = get_move(current_player)
            if is_move_available(board, move_coords):
                return move_coords
        except KeyboardInterrupt:
            sys.exit(1)


def assign_player_symbol():
    """Randomly pick a symbol ('X' or 'O') and return it."""
    coin_toss = random.randint(0, 1)
    if coin_toss == 0:
        return 'X'
    else:
        return 'O'


def get_opponent(player):
    """Return the opponent's symbol.

    Return 'O' if the player is 'X', otherwise return 'X'.
    """
    if player == 'X':
        return 'O'
    else:
        return 'X'


def minimax_score(board, current_player, ai_symbol):
    """Calculate score for board using minimax algorithm and return it.

    'ai_symbol' is the player whose score we are trying to maximize.
    If a board is already in the cache, retrieve its score and return it.
    Otherwise, recursively loop through all possible board states until a
    game-ending state is found.
    A state where 'ai_symbol' wins gets a score of 10.
    A draw gets a score of 0.
    A state where the opponent wins gets a score of -10.
    The score is carried back up to the board states that led to the
    game-ending state.
    A board is assigned a score based on the best-possible outcome
    'ai_symbol' can reach (i.e. 10 if it is possible to win, 0 if it
    can at best draw, -10 if the only outcome is a loss).
    Assumes optimal play from opponent.
    """
    board_id = board_to_string(board)
    if board_id in minimax_cache:
        return minimax_cache[board_id]

    opponent_symbol = get_opponent(ai_symbol)
    winner = get_winner(board)
    if winner == ai_symbol:
        return 10
    elif winner == opponent_symbol:
        return -10
    elif check_draw(board):
        return 0

    available_moves = get_all_available_moves(board)
    scores = []
    for move in available_moves:
        next_board = make_move(board, move, current_player)
        next_player = get_opponent(current_player)
        score = minimax_score(next_board, next_player, ai_symbol)
        scores.append(score)
        next_board_id = board_to_string(next_board)
        if next_board_id not in minimax_cache:
            add_rotations_to_cache(next_board, score)

    if current_player == ai_symbol:
        add_rotations_to_cache(board, max(scores))
        return max(scores)
    else:
        add_rotations_to_cache(board, min(scores))
        return min(scores)


def minimax_ai(board, current_player):
    """Return best possible move.

    This CPU cannot lose! At worst it will draw.
    First, checks if there is a move that will immediately win and if it
    finds one returns it.
    If no move can immediately win, calculates minimax scores for all
    available moves and returns move with highest score.
    If the highest score is 0 (best outcome a draw), and there are
    multiple moves with a score of 0, use heuristics to choose one.
    """
    available_moves = get_all_available_moves(board)
    highest_score = -1
    best_move = None
    drawing_moves = []
    for move in available_moves:
        next_board = make_move(board, move, current_player)
        if get_winner(next_board) == current_player:
            return move
        next_player = get_opponent(current_player)
        score = minimax_score(next_board, next_player, current_player)
        if score > highest_score:
            highest_score = score
            best_move = move
        if highest_score == 0 and score == 0:
            drawing_moves.append(move)

    if highest_score == 0 and len(drawing_moves) > 1:
        return tie_break(board, current_player, drawing_moves)

    return best_move


def tie_break(board, current_player, drawing_moves):
    """Return 'best' move according to heuristics.

    'drawing_moves' is a list of moves that will lead to a draw
    assuming optimal responses by the opponent.
    Though the moves are all equal, some may be trickier than others (if we
    assume the opponent is capable of making mistakes).
    A move that makes 'two-in-a-row' is worth 2 points.
    A move in a corner position is worth 1 point.
    Calculate heuristic scores for all moves in 'drawing_moves' and
    return the one with the highest score.
    If multiple moves share the highest score, pick between them randomly.
    """
    tie_break_score = -1
    move_dict = {}
    for move in drawing_moves:
        s = 0
        if check_two_in_a_lane(board, move, current_player):
            s += 2
        if corner_move(move):
            s += 1
        if s > tie_break_score:
            tie_break_score = s
        move_dict[move] = s

    best_moves = [k for k, v in move_dict.items() if v == tie_break_score]
    random_best_move = random.choice(best_moves)
    return random_best_move


def get_move_lanes(board, move):
    """Return list of lanes that the move is in.

    List will always include a row and a column.
    If move is on a diagonal, include it.
    If move is in the center, include both diagonals.
    """
    moves_on_diags = [(0, 0), (2, 0), (0, 2), (2, 2), (1, 1)]
    move_lanes = []
    x = move[0]
    y = move[1]

    # Add move's row to the list
    move_lanes.append(board[y])

    # Add move's column to the list
    col = []
    for row in board:
        col.append(row[x])
    move_lanes.append(col)

    # Add diagonals to list, if move is on them
    if move not in moves_on_diags:
        return move_lanes
    top_left_diag = [board[0][0], board[1][1], board[2][2]]
    top_right_diag = [board[0][2], board[1][1], board[2][0]]
    if move == (0, 0) or move == (2, 2):
        move_lanes.append(top_left_diag)
    elif move == (2, 0) or move == (0, 2):
        move_lanes.append(top_right_diag)
    else:
        move_lanes.append(top_left_diag)
        move_lanes.append(top_right_diag)
    return move_lanes


def check_two_in_a_lane(board, move, current_player):
    """Return True if move will make 'two-in-a-row', otherwise False.

    Returns True if the move is on a lane that:
    already has the current player's symbol in it;
    has an empty cell in it;
    and does not have the opponent's symbol in it.
    Returns False otherwise.
    """
    move_lanes = get_move_lanes(board, move)
    opponent = get_opponent(current_player)
    for lane in move_lanes:
        if (current_player in lane
                and None in lane
                and opponent not in lane):
            return True
    return False


def corner_move(move):
    """Return True if the move is on a corner, otherwise return False"""
    if move in [(0, 0), (2, 0), (0, 2), (2, 2)]:
        return True
    return False


def main():
    """Start the game"""
    number_of_players = get_number_of_players()
    board = new_board()
    if number_of_players == 0:
        x_ai = get_ai_level('X')
        o_ai = get_ai_level('O')
        render(board)
        cpu_vs_cpu(board, 'X', x_ai, o_ai)
    elif number_of_players == 1:
        ai_level = get_ai_level(None)
        render(board)
        play_vs_cpu(board, 'X', assign_player_symbol(), ai_level)
    else:
        render(board)
        play(board, 'X')


if __name__ == '__main__':
    main()
